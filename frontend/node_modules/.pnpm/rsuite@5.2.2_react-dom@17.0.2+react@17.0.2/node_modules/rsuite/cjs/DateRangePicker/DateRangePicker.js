"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.default = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutPropertiesLoose"));

var _Calendar = _interopRequireDefault(require("@rsuite/icons/legacy/Calendar"));

var _isUndefined = _interopRequireDefault(require("lodash/isUndefined"));

var _omit = _interopRequireDefault(require("lodash/omit"));

var _partial = _interopRequireDefault(require("lodash/partial"));

var _pick = _interopRequireDefault(require("lodash/pick"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireWildcard(require("react"));

var _CustomProvider = require("../CustomProvider");

var _Toolbar = _interopRequireDefault(require("../DatePicker/Toolbar"));

var _Picker = require("../Picker");

var _utils = require("../utils");

var _dateUtils = require("../utils/dateUtils");

var _Calendar2 = _interopRequireDefault(require("./Calendar"));

var disabledDateUtils = _interopRequireWildcard(require("./disabledDateUtils"));

var _utils2 = require("./utils");

var DateRangePicker = /*#__PURE__*/_react.default.forwardRef(function (props, ref) {
  var _ref, _merge;

  var _props$as = props.as,
      Component = _props$as === void 0 ? 'div' : _props$as,
      _props$classPrefix = props.classPrefix,
      classPrefix = _props$classPrefix === void 0 ? 'picker' : _props$classPrefix,
      className = props.className,
      _props$appearance = props.appearance,
      appearance = _props$appearance === void 0 ? 'default' : _props$appearance,
      _props$cleanable = props.cleanable,
      cleanable = _props$cleanable === void 0 ? true : _props$cleanable,
      _props$character = props.character,
      character = _props$character === void 0 ? ' ~ ' : _props$character,
      defaultCalendarValue = props.defaultCalendarValue,
      defaultValue = props.defaultValue,
      disabled = props.disabled,
      disabledDateProp = props.disabledDate,
      _props$format = props.format,
      formatStr = _props$format === void 0 ? 'yyyy-MM-dd' : _props$format,
      hoverRange = props.hoverRange,
      isoWeek = props.isoWeek,
      _props$limitEndYear = props.limitEndYear,
      limitEndYear = _props$limitEndYear === void 0 ? 1000 : _props$limitEndYear,
      overrideLocale = props.locale,
      menuClassName = props.menuClassName,
      menuStyle = props.menuStyle,
      oneTap = props.oneTap,
      _props$placeholder = props.placeholder,
      placeholder = _props$placeholder === void 0 ? '' : _props$placeholder,
      _props$placement = props.placement,
      placement = _props$placement === void 0 ? 'bottomStart' : _props$placement,
      ranges = props.ranges,
      renderValue = props.renderValue,
      _props$showOneCalenda = props.showOneCalendar,
      showOneCalendar = _props$showOneCalenda === void 0 ? false : _props$showOneCalenda,
      showWeekNumbers = props.showWeekNumbers,
      style = props.style,
      toggleAs = props.toggleAs,
      valueProp = props.value,
      onChange = props.onChange,
      onClean = props.onClean,
      onClose = props.onClose,
      onEnter = props.onEnter,
      onEntered = props.onEntered,
      onExited = props.onExited,
      onOk = props.onOk,
      onOpen = props.onOpen,
      onSelect = props.onSelect,
      rest = (0, _objectWithoutPropertiesLoose2.default)(props, ["as", "classPrefix", "className", "appearance", "cleanable", "character", "defaultCalendarValue", "defaultValue", "disabled", "disabledDate", "format", "hoverRange", "isoWeek", "limitEndYear", "locale", "menuClassName", "menuStyle", "oneTap", "placeholder", "placement", "ranges", "renderValue", "showOneCalendar", "showWeekNumbers", "style", "toggleAs", "value", "onChange", "onClean", "onClose", "onEnter", "onEntered", "onExited", "onOk", "onOpen", "onSelect"]);

  var _useClassNames = (0, _utils.useClassNames)(classPrefix),
      merge = _useClassNames.merge,
      prefix = _useClassNames.prefix;

  var _useCustom = (0, _utils.useCustom)('DateRangePicker', overrideLocale),
      locale = _useCustom.locale,
      formatDate = _useCustom.formatDate,
      parseDate = _useCustom.parseDate;

  var rangeFormatStr = "" + formatStr + character + formatStr;

  var _useControlled = (0, _utils.useControlled)(valueProp, defaultValue !== null && defaultValue !== void 0 ? defaultValue : []),
      value = _useControlled[0],
      setValue = _useControlled[1];
  /**
   * Whether to complete the selection.
   * Everytime selection will change this value. If the value is false, it means that the selection has not been completed.
   *
   * In `oneTap` mode, select action will not change this value, its value should be true always.
   */


  var hasDoneSelect = (0, _react.useRef)(true);
  /**
   * The currently selected date range.
   *
   * The time range is selected by two clicks. After the first click,
   * the cursor will store a temporary event date in the process until
   * the second click to determine the end date of the date range.
   *
   */

  var _useState = (0, _react.useState)((_ref = valueProp !== null && valueProp !== void 0 ? valueProp : defaultValue) !== null && _ref !== void 0 ? _ref : []),
      selectValue = _useState[0],
      setSelectValue = _useState[1]; // The date of the current hover, used to reduce the calculation of `handleMouseMove`


  var _useState2 = (0, _react.useState)([]),
      hoverValue = _useState2[0],
      setHoverValue = _useState2[1]; // The displayed calendar panel is rendered based on this value.


  var _useState3 = (0, _react.useState)((0, _utils2.getCalendarDate)({
    value: valueProp !== null && valueProp !== void 0 ? valueProp : defaultCalendarValue
  })),
      calendarDate = _useState3[0],
      setCalendarDate = _useState3[1];

  var _useState4 = (0, _react.useState)(),
      inputState = _useState4[0],
      setInputState = _useState4[1];
  /**
   * When hoverRange is set, `selectValue` will be updated during the hover process,
   * which will cause the `selectValue` to be updated after the first click,
   * so declare a Ref to temporarily store the `selectValue` of the first click.
   */


  var selectRangeValueRef = (0, _react.useRef)(null);
  /**
   * Call this function to update the calendar panel rendering benchmark value.
   * If params `value` is not passed, it defaults to [new Date(), addMonth(new Date(), 1)].
   */

  var updateCalendarDate = (0, _react.useCallback)(function (value) {
    setCalendarDate((0, _utils2.getCalendarDate)({
      value: value
    }));
  }, []); // if valueProp changed then update selectValue/hoverValue

  (0, _react.useEffect)(function () {
    setSelectValue(valueProp !== null && valueProp !== void 0 ? valueProp : []);
    setHoverValue(valueProp !== null && valueProp !== void 0 ? valueProp : []);
  }, [valueProp]);

  var _useState5 = (0, _react.useState)(false),
      isPickerToggleActive = _useState5[0],
      setPickerToggleActive = _useState5[1];

  var rootRef = (0, _react.useRef)();
  var overlayRef = (0, _react.useRef)();
  var targetRef = (0, _react.useRef)();
  var triggerRef = (0, _react.useRef)();
  var handleCloseDropdown = (0, _react.useCallback)(function () {
    var _triggerRef$current, _triggerRef$current$c;

    (_triggerRef$current = triggerRef.current) === null || _triggerRef$current === void 0 ? void 0 : (_triggerRef$current$c = _triggerRef$current.close) === null || _triggerRef$current$c === void 0 ? void 0 : _triggerRef$current$c.call(_triggerRef$current);
  }, []);
  (0, _Picker.usePublicMethods)(ref, {
    triggerRef: triggerRef,
    overlayRef: overlayRef,
    targetRef: targetRef,
    rootRef: rootRef
  });
  var getDisplayString = (0, _react.useCallback)(function (nextValue, isPlaintext) {
    var _nextValue, _nextValue2;

    if (nextValue === void 0) {
      nextValue = value;
    }

    var startDate = (_nextValue = nextValue) === null || _nextValue === void 0 ? void 0 : _nextValue[0];
    var endDate = (_nextValue2 = nextValue) === null || _nextValue2 === void 0 ? void 0 : _nextValue2[1];

    if (startDate && endDate) {
      var displayValue = [startDate, endDate].sort(_dateUtils.compareAsc);

      if (isPlaintext) {
        return formatDate(displayValue[0], formatStr) + character + formatDate(displayValue[1], formatStr);
      }

      return renderValue ? renderValue(displayValue, formatStr) : /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(_CustomProvider.FormattedDate, {
        date: displayValue[0],
        formatStr: formatStr
      }), character, /*#__PURE__*/_react.default.createElement(_CustomProvider.FormattedDate, {
        date: displayValue[1],
        formatStr: formatStr
      }));
    }

    return isPlaintext ? '' : placeholder || rangeFormatStr;
  }, [character, formatDate, formatStr, placeholder, rangeFormatStr, renderValue, value]);
  /**
   * preset hover range
   */

  var getHoverRangeValue = (0, _react.useCallback)(function (date) {
    if (!hoverRange) {
      return [];
    }

    var hoverRangeFunc = hoverRange;

    if (hoverRange === 'week') {
      hoverRangeFunc = (0, _partial.default)(_utils2.getWeekHoverRange, isoWeek);
    }

    if (hoverRangeFunc === 'month') {
      hoverRangeFunc = _utils2.getMonthHoverRange;
    }

    if (typeof hoverRangeFunc !== 'function') {
      return [];
    }

    var hoverValues = hoverRangeFunc(date);
    var isHoverRangeValid = hoverValues instanceof Array && hoverValues.length === 2;

    if (!isHoverRangeValid) {
      return [];
    }

    if (_utils.DateUtils.isAfter(hoverValues[0], hoverValues[1])) {
      hoverValues.reverse();
    }

    return hoverValues;
  }, [hoverRange, isoWeek]);
  var handleValueUpdate = (0, _react.useCallback)(function (event, nextSelectValue, closeOverlay) {
    if (closeOverlay === void 0) {
      closeOverlay = true;
    }

    var nextValue = !(0, _isUndefined.default)(nextSelectValue) ? nextSelectValue : selectValue;
    setSelectValue(nextValue || []);

    if (!(0, _utils2.isSameRange)(nextValue, value, formatStr)) {
      setValue(nextValue);
      onChange === null || onChange === void 0 ? void 0 : onChange(nextValue, event);
    } // `closeOverlay` default value is `true`


    if (closeOverlay !== false) {
      handleCloseDropdown();
    }
  }, [formatStr, handleCloseDropdown, onChange, selectValue, setValue, value]);
  /**
   * Select the date range. If oneTap is not set, you need to click twice to select the start time and end time.
   * The MouseMove event is called between the first click and the second click to update the selection state.
   */

  var handleMouseMove = (0, _react.useCallback)(function (date) {
    var hoverRangeValue = getHoverRangeValue(date); // After the first click

    if (!hasDoneSelect.current) {
      // If hoverRange is set, you need to change the value of hoverValue according to the rules
      if (hoverRange) {
        var nextHoverValue = [selectRangeValueRef.current[0], hoverRangeValue[1]];

        if (_utils.DateUtils.isBefore(hoverRangeValue[0], selectRangeValueRef.current[0])) {
          nextHoverValue[0] = hoverRangeValue[0];
          nextHoverValue[1] = selectRangeValueRef.current[1];
        }

        setSelectValue(nextHoverValue);
      } else {
        setHoverValue(function (prevHoverValue) {
          return [prevHoverValue[0], date];
        });
      } // Before the first click, if hoverRangeValue has a value, hoverValue needs to be updated

    } else if (hoverRange && hoverRangeValue.length) {
      setHoverValue(hoverRangeValue);
    }
  }, [getHoverRangeValue, hoverRange]);
  var handleSelectValueChange = (0, _react.useCallback)(function (date, event) {
    var nextSelectValue = Array.from(hoverValue);
    var hoverRangeValue = getHoverRangeValue(date);
    var noHoverRangeValid = hoverRangeValue.length !== 2; // in `oneTap` mode

    if (hasDoneSelect.current && oneTap) {
      handleValueUpdate(event, noHoverRangeValid ? [(0, _utils2.setTimingMargin)(date), (0, _utils2.setTimingMargin)(date, 'right')] : hoverRangeValue);
      hasDoneSelect.current = false;
      return;
    } // no preset hover range can use


    if (noHoverRangeValid) {
      // start select
      if (hasDoneSelect.current) {
        nextSelectValue = [date];
      } else {
        // finish select
        nextSelectValue[1] = date;
      }
    } else {
      if (!hasDoneSelect.current) {
        nextSelectValue = selectValue;
        selectRangeValueRef.current = null;
      } else {
        nextSelectValue = hoverRangeValue;
        selectRangeValueRef.current = hoverRangeValue;
      }
    } // If user have completed the selection, then sort


    if (nextSelectValue.length === 2 && _utils.DateUtils.isAfter(nextSelectValue[0], nextSelectValue[1])) {
      nextSelectValue.reverse();
    }

    setHoverValue(nextSelectValue);
    setSelectValue(nextSelectValue);
    updateCalendarDate(nextSelectValue);
    onSelect === null || onSelect === void 0 ? void 0 : onSelect(date, event);
    hasDoneSelect.current = !hasDoneSelect.current;
  }, [getHoverRangeValue, handleValueUpdate, hoverValue, onSelect, oneTap, selectValue, updateCalendarDate]);
  /**
   * If `selectValue` changed, there will be the following effects.
   * 1. Check if the selection is completed.
   * 2. if the selection is completed, set the temporary `hoverValue` empty.
   */

  (0, _react.useEffect)(function () {
    var _selectValue$length;

    var selectValueLength = (_selectValue$length = selectValue === null || selectValue === void 0 ? void 0 : selectValue.length) !== null && _selectValue$length !== void 0 ? _selectValue$length : 0;
    var doneSelected = selectValueLength === 0 || selectValueLength === 2;
    doneSelected && setHoverValue([]);
  }, [selectValue]);
  var handleChangeCalendarDate = (0, _react.useCallback)(function (index, date) {
    var nextCalendarDate = Array.from(calendarDate);
    nextCalendarDate[index] = date;
    updateCalendarDate(nextCalendarDate);
  }, [calendarDate, updateCalendarDate]);
  var handleChangeCalendarTime = (0, _react.useCallback)(function (index, date) {
    setSelectValue(function (prev) {
      var next = [].concat(prev);
      var clonedDate = new Date(date.valueOf()); // if next[index] is not empty, only update the time after aligning the year, month and day

      if (next[index]) {
        clonedDate.setFullYear(next[index].getFullYear(), next[index].getMonth(), next[index].getDate());
      }

      next[index] = clonedDate;
      return next;
    });
    handleChangeCalendarDate(index, date);
  }, [handleChangeCalendarDate]);
  /**
   * Toolbar operation callback function
   */

  var handleShortcutPageDate = (0, _react.useCallback)(function (value, closeOverlay, event) {
    handleValueUpdate(event, value, closeOverlay);
  }, [handleValueUpdate]);
  var handleOK = (0, _react.useCallback)(function (event) {
    handleValueUpdate(event);
    onOk === null || onOk === void 0 ? void 0 : onOk(selectValue, event);
  }, [handleValueUpdate, onOk, selectValue]);
  var handleClean = (0, _react.useCallback)(function (event) {
    updateCalendarDate();
    handleValueUpdate(event, []);
  }, [handleValueUpdate, updateCalendarDate]);
  /**
   * Callback after the input box value is changed.
   */

  var handleInputChange = (0, _react.useCallback)(function (value) {
    setInputState('Typing');
    var rangeValue = value.split(character); // isMatch('01/11/2020', 'MM/dd/yyyy') ==> true
    // isMatch('2020-11-01', 'MM/dd/yyyy') ==> false

    if (!_utils.DateUtils.isMatch(rangeValue[0], formatStr, {
      locale: locale.dateLocale
    }) || !_utils.DateUtils.isMatch(rangeValue[1], formatStr, {
      locale: locale.dateLocale
    })) {
      setInputState('Error');
      return;
    }

    var startDate = parseDate(rangeValue[0], formatStr);
    var endDate = parseDate(rangeValue[1], formatStr);
    var selectValue = [startDate, endDate];

    if (!_utils.DateUtils.isValid(startDate) || !_utils.DateUtils.isValid(endDate)) {
      setInputState('Error');
      return;
    }

    if (disabledDate(startDate, selectValue, true, _utils.DATERANGE_DISABLED_TARGET.CALENDAR)) {
      setInputState('Error');
      return;
    }

    setHoverValue(selectValue);
    setSelectValue(selectValue);
    updateCalendarDate(selectValue);
  }, // eslint-disable-next-line react-hooks/exhaustive-deps
  [character, rangeFormatStr, updateCalendarDate]);
  /**
   * The callback after the enter key is triggered on the input
   */

  var handleInputPressEnd = (0, _react.useCallback)(function (event) {
    if (inputState === 'Typing') {
      handleValueUpdate(event, selectValue);
    }

    setInputState('Initial');
  }, [handleValueUpdate, selectValue, inputState]);
  var handleEnter = (0, _react.useCallback)(function () {
    var nextCalendarDate;

    if (value && value.length) {
      var _startDate = value[0],
          endData = value[1];
      nextCalendarDate = [_startDate, (0, _dateUtils.isSameMonth)(_startDate, endData) ? (0, _dateUtils.addMonths)(endData, 1) : endData];
    } else {
      nextCalendarDate = (0, _utils2.getCalendarDate)({
        value: defaultCalendarValue
      });
    }

    setSelectValue(value);
    updateCalendarDate(nextCalendarDate);
  }, [defaultCalendarValue, updateCalendarDate, setSelectValue, value]);
  var handleEntered = (0, _react.useCallback)(function () {
    onOpen === null || onOpen === void 0 ? void 0 : onOpen();
    setPickerToggleActive(true);
  }, [onOpen]);
  var handleExited = (0, _react.useCallback)(function () {
    setPickerToggleActive(false);
    hasDoneSelect.current = true;
    onClose === null || onClose === void 0 ? void 0 : onClose();
  }, [onClose]);
  var disabledDate = (0, _react.useCallback)(function (date, selectDate, selectedDone, target) {
    return disabledDateProp === null || disabledDateProp === void 0 ? void 0 : disabledDateProp(date, selectDate, selectedDone, target);
  }, [disabledDateProp]);
  var disabledByBetween = (0, _react.useCallback)(function (start, end, type) {
    var selectStartDate = selectValue[0],
        selectEndDate = selectValue[1];
    var nextSelectValue = [selectStartDate, selectEndDate]; // If the date is between the start and the end
    // the button is disabled

    while (_utils.DateUtils.isBefore(start, end) || _utils.DateUtils.isSameDay(start, end)) {
      if (disabledDate(start, nextSelectValue, hasDoneSelect.current, type)) {
        return true;
      }

      start = _utils.DateUtils.addDays(start, 1);
    }

    return false;
  }, [disabledDate, selectValue]);
  var disabledOkButton = (0, _react.useCallback)(function () {
    var start = selectValue[0],
        end = selectValue[1];

    if (!start || !end || !hasDoneSelect.current) {
      return true;
    }

    return disabledByBetween(start, end, _utils.DATERANGE_DISABLED_TARGET.TOOLBAR_BUTTON_OK);
  }, [disabledByBetween, selectValue]);
  var disabledShortcutButton = (0, _react.useCallback)(function (value) {
    if (value === void 0) {
      value = [];
    }

    var _value = value,
        start = _value[0],
        end = _value[1];

    if (!start || !end) {
      return true;
    }

    return disabledByBetween(start, end, _utils.DATERANGE_DISABLED_TARGET.TOOLBAR_SHORTCUT);
  }, [disabledByBetween]);
  var handleDisabledDate = (0, _react.useCallback)(function (date, values, type) {
    return disabledDate(date, values, hasDoneSelect.current, type);
  }, [disabledDate]);
  var onPickerKeyDown = (0, _Picker.useToggleKeyDownEvent)((0, _extends2.default)({
    triggerRef: triggerRef,
    targetRef: targetRef,
    active: isPickerToggleActive,
    onExit: handleClean
  }, rest));

  var renderDropdownMenu = function renderDropdownMenu(positionProps, speakerRef) {
    var left = positionProps.left,
        top = positionProps.top,
        className = positionProps.className;
    var classes = merge(className, menuClassName, prefix('daterange-menu'));
    var panelClasses = prefix('daterange-panel', {
      'daterange-panel-show-one-calendar': showOneCalendar
    });
    var styles = (0, _extends2.default)({}, menuStyle, {
      left: left,
      top: top
    });
    var panelProps = {
      calendarDate: calendarDate,
      disabledDate: handleDisabledDate,
      format: formatStr,
      hoverRangeValue: hoverValue,
      isoWeek: isoWeek,
      limitEndYear: limitEndYear,
      locale: locale,
      showOneCalendar: showOneCalendar,
      showWeekNumbers: showWeekNumbers,
      value: selectValue,
      onChangeCalendarDate: handleChangeCalendarDate,
      onChangeCalendarTime: handleChangeCalendarTime,
      onMouseMove: handleMouseMove,
      onSelect: handleSelectValueChange
    };
    return /*#__PURE__*/_react.default.createElement(_Picker.PickerOverlay, {
      className: classes,
      ref: (0, _utils.mergeRefs)(overlayRef, speakerRef),
      target: triggerRef,
      style: styles
    }, /*#__PURE__*/_react.default.createElement("div", {
      className: panelClasses
    }, /*#__PURE__*/_react.default.createElement("div", {
      className: prefix('daterange-content')
    }, /*#__PURE__*/_react.default.createElement("div", {
      className: prefix('daterange-header')
    }, getDisplayString(selectValue)), /*#__PURE__*/_react.default.createElement("div", {
      className: prefix("daterange-calendar-" + (showOneCalendar ? 'single' : 'group'))
    }, /*#__PURE__*/_react.default.createElement(_Calendar2.default, (0, _extends2.default)({
      index: 0
    }, panelProps)), !showOneCalendar && /*#__PURE__*/_react.default.createElement(_Calendar2.default, (0, _extends2.default)({
      index: 1
    }, panelProps)))), /*#__PURE__*/_react.default.createElement(_Toolbar.default, {
      locale: locale,
      calendarDate: selectValue,
      disabledOkBtn: disabledOkButton,
      disabledShortcut: disabledShortcutButton,
      hideOkBtn: oneTap,
      onOk: handleOK,
      onClickShortcut: handleShortcutPageDate,
      ranges: ranges
    })));
  };

  var hasValue = value && value.length > 1;

  var _usePickerClassName = (0, _Picker.usePickerClassName)((0, _extends2.default)({}, props, {
    classPrefix: classPrefix,
    name: 'daterange',
    appearance: appearance,
    hasValue: hasValue,
    cleanable: cleanable
  })),
      classes = _usePickerClassName[0],
      usedClassNamePropKeys = _usePickerClassName[1];

  return /*#__PURE__*/_react.default.createElement(_Picker.PickerToggleTrigger, {
    pickerProps: (0, _pick.default)(props, _Picker.pickTriggerPropKeys),
    ref: triggerRef,
    placement: placement,
    onEnter: (0, _utils.createChainedFunction)(handleEnter, onEnter),
    onEntered: (0, _utils.createChainedFunction)(handleEntered, onEntered),
    onExited: (0, _utils.createChainedFunction)(handleExited, onExited),
    speaker: renderDropdownMenu
  }, /*#__PURE__*/_react.default.createElement(Component, {
    ref: rootRef,
    className: merge(className, classes, (_merge = {}, _merge[prefix('error')] = inputState === 'Error', _merge)),
    style: style
  }, /*#__PURE__*/_react.default.createElement(_Picker.PickerToggle, (0, _extends2.default)({}, (0, _omit.default)(rest, [].concat(_Picker.omitTriggerPropKeys, usedClassNamePropKeys, _utils.DateUtils.calendarOnlyProps)), {
    as: toggleAs,
    ref: targetRef,
    appearance: appearance,
    input: true,
    inputMask: _utils.DateUtils.getDateMask(rangeFormatStr),
    inputValue: value ? getDisplayString(value, true) : '',
    inputPlaceholder: typeof placeholder === 'string' && placeholder ? placeholder : rangeFormatStr,
    onInputChange: handleInputChange,
    onInputBlur: handleInputPressEnd,
    onInputPressEnter: handleInputPressEnd,
    onKeyDown: onPickerKeyDown,
    onClean: (0, _utils.createChainedFunction)(handleClean, onClean),
    cleanable: cleanable && !disabled,
    hasValue: hasValue,
    active: isPickerToggleActive,
    placement: placement,
    caretComponent: _Calendar.default,
    disabled: disabled
  }), getDisplayString())));
});

DateRangePicker.after = disabledDateUtils.after;
DateRangePicker.afterToday = disabledDateUtils.afterToday;
DateRangePicker.allowedDays = disabledDateUtils.allowedDays;
DateRangePicker.allowedMaxDays = disabledDateUtils.allowedMaxDays;
DateRangePicker.allowedRange = disabledDateUtils.allowedRange;
DateRangePicker.before = disabledDateUtils.before;
DateRangePicker.beforeToday = disabledDateUtils.beforeToday;
DateRangePicker.combine = disabledDateUtils.combine;
DateRangePicker.displayName = 'DateRangePicker';
DateRangePicker.propTypes = (0, _extends2.default)({}, _Picker.pickerPropTypes, {
  ranges: _propTypes.default.array,
  value: _propTypes.default.arrayOf(_propTypes.default.instanceOf(Date)),
  defaultValue: _propTypes.default.arrayOf(_propTypes.default.instanceOf(Date)),
  defaultCalendarValue: _propTypes.default.arrayOf(_propTypes.default.instanceOf(Date)),
  hoverRange: _propTypes.default.oneOfType([_propTypes.default.oneOf(['week', 'month']), _propTypes.default.func]),
  format: _propTypes.default.string,
  isoWeek: _propTypes.default.bool,
  oneTap: _propTypes.default.bool,
  limitEndYear: _propTypes.default.number,
  showWeekNumbers: _propTypes.default.bool,
  onChange: _propTypes.default.func,
  onOk: _propTypes.default.func,
  disabledDate: _propTypes.default.func,
  onSelect: _propTypes.default.func,
  showOneCalendar: _propTypes.default.bool
});
var _default = DateRangePicker;
exports.default = _default;